{"version":3,"sources":["ts/enums/element-ids.enum.ts","../node_modules/assemblyscript/lib/loader/index.js","ts/functions/fibonacci.function.ts","ts/functions/get-elapsed-seconds.function.ts","ts/functions/get-input-value.function.ts","ts/functions/get-result-string.function.ts","ts/functions/output-result.function.ts","ts/functions/index.ts","ts/index.ts"],"names":[],"mappings":"ACAA;AACA;AACA;AACA;AACA;AACA,ADLA,IAAY,UAAZ;ACMA,ACNA,ACAA,ACAA,ACAA,ACAA,AEAA,IAAA,KNAgB,ACAA,ACAA,ACAA,ACAA,YAAhB,CAA6B,AEA7B,EHAA,CAAgC,AGAhC,EJAA,CFAA,AEAmC,CFAC,CAApC,ACAA,AGAA,CHAsC,AEAtC,CHA6C,AIAE,AEA/C,CHAwD,AGAxD,EJAA,CDAA,CCAkD,CDAC,AGAnD,EAA6D,IDA7D,EAA2E,aGA3E,CAAA;APOA,ADPA,AECE,ACAE,ACAA,ACAA,ACAA,CNDJ,CMCI,IJAE,ACAI,AEAF,CHAD,ECAM,ACAF,CEAC,CNDA,AMCC,CJAD,ACAI,CDAd,EAAa,AEAE,CDAG,ACAiB,CDAhB,CEAD,EFAJ,CHDhB,AKCuB,CHAD,ACAlB,CHDkB,AECP,CEA8B,CAAC,AEA1C,CAAwB,QAAxB,EAAkC,GFAD,CAAwB,ACArB,ODAH,AEAjC,EFAmE,CEAnB,CDAhD,GDAa,CAAb,CEAA;ALOJ,ADPI,AECF,ACAE,ACAH,AEAA,AEAD,ERDI,EQCJ,ENAM,ACAE,CDAD,KFDH,AECQ,AMAZ,CRDI,AECF,ACAa,EDAA,AMAf,CLAkB,GAAG,GDAC,ACAE,AKAxB,CNAe,AMAf,GRDI,CAAA,AGCA,GHDA,cAAA,MQCJ,CAAA;APOA,ADPI,AECF,ACAE,AEDA,ELAA,IKAG,GHCE,ACAK,GHDV,AKAA,CLAA,CKAU,EFCO,GAAA,SDAO,CAAC,CAAC,EFD1B,CAAA,AEC6B,ACA7B,CDAwB,CAAnB,CFDL,EECkC,mBFDlC,AECqD,CAAC,CAAC,GAAG,CAAL,CAAvD;ADOF,ADPI,AECH,ACAA,ACJD,ACGQ,ACHR,AEGA,ERAI,EKAI,AGAR,GJHA,AEAA,CFAA,AEAA,GEGA,CRAI,CAAA,CQAJ,EHAoB,GAAG,CCHvB,CEGA,CAAA,CFHA,GFAA,GAAA,GCGkC,CLA9B,CAAA,CMHJ,ENGI,CKAmB,GAAiB,AGAxC,CAAA,GHAuB,EDHvB,CCG+C,WLA3C,CKAI;AJQR,ADPI,AKAC,ELAD,UAAA,CAAA,iBAAA,CAAA,GAAA,mBAAA;ACQJ,ADPI,AELJ,ACAA,AIAA,ACKA,ERAI,EQAA,GNLJ,ACAA,CDAA,ACAA,AIAA,CAAA,GPKI,CAAA,CQAJ,EDLA,CAAA,ULAA,ECAA,CHKI,AELJ,CFKI,CGLJ,EHKI,KOLJ,CAAA,CAAA,QLAA,IFKI,AGLJ;AFaA,ADPI,AKDA,AGEJ,ERDI,EQCA,KHFO,GLCP,CAAA,QKDA,AGEJ,cRDI,CAAA,GAAA,eAAA;ACQJ,ADPI,AKDH,AELD,ACOA,ERDI,EQCA,IDPJ,CAAA,GPMI,CAAA,GONJ,CAAA,MCOA,YRDI,CAAA,GAAA,UONJ,CAAA,CAAA,GPMI;ACQJ,ADPI,AQEJ,ERFI,EQEE,OAAO,CRFT,CAAA,CQEY,uBRFZ,CAAA,GAAA,iBAAA;ACQJ,ADPI,AKTJ,AEEA,ACSI,ERFA,AQEA,GAAG,EHXP,AGWS,CHXT,AEEA,CAAA,GPOI,CAAA,GOPJ,CAAA,MFFA,GAAA,WLSI,CAAA,GAAA,AKTJ,IEEA,CAAA,CAAA,WPOI;ACQJ,ADPC,AQEO,CRZR,EAAY,CQYJ,KAAK,EAAA,ERZS,GAAV,OAAA,CAAA,EQYE,IAAD,EAAO,ERZR,GQYC,ERZD,AQYe,IAAd,EAAoB,CRZrB,CAAA,IQYC,EAA0B,IRZ3B,GAAU,EAAV,CAAZ;ACkBA,AMfA,ACUY,MAAA,EDVZ,CAAA,ICUmB,CAAC,EDVpB,CAAA,ECUY,CAAc,2BDV1B,CAAA,CAAA,CCUwD,IAA9B,GAAqC,GAArC,GAA2C,MAAzD;APMZ,AOLS,KAHA;APST,AMhBA,ACWQ,IAAA,IDXR,CAAA,OAAA,ACWoB,CDXpB,CCWQ,sBAAa,CAAb,EDXR,ACW8B,CDX9B,CAAA;ANiBA,AOLY,MAAA,OAAO,CAAC,GAAR,CAAY,kBAAgB,CAA5B;APMZ,AOLS;APMT,AOZS;APaT,AOdgB,CAAhB;APeA,AOJA,cAAc;APKd,AOHA,QAAQ,CAAC,gBAAT,CAA0B,kBAA1B,EAA8C,YAAA;API9C,AOFI,EAAA,QAAQ,CAAC,cAAT,CAAwB,kBAAA,CAAA,UAAA,CAAW,eAAnC,EAAoD,gBAApD,CAAqE,OAArE,EAA8E,YAAA;APGlF,AOFQ,IAAA,wBAAwB,CAAC,OAAA,CAAA,mBAAD,EAAsB,kBAAA,CAAA,UAAA,CAAW,oBAAjC,CAAxB;APGR,AODQ,IAAA,wBAAwB,CAAC,UAAU,CAAC,aAAZ,EAA2B,kBAAA,CAAA,UAAA,CAAW,sBAAtC,CAAxB;APER,AODK,GAJD;APMJ,AOAI,EAAA,QAAQ,CAAC,cAAT,CAAwB,kBAAA,CAAA,UAAA,CAAW,eAAnC,EAAoD,gBAApD,CAAqE,OAArE,EAA8E,YAAA;APClF,AOAQ,QAAM,MAAM,GAAsB,QAAQ,CAAC,cAAT,CAAwB,kBAAA,CAAA,UAAA,CAAW,iBAAnC,EAAuD,KAAzF;APCR,AOAQ,QAAM,OAAO,GAAsB,QAAQ,CAAC,cAAT,CAAwB,kBAAA,CAAA,UAAA,CAAW,kBAAnC,EAAwD,KAA3F;APCR,AOAQ,QAAI,SAAJ;APCR,AOAQ,QAAI,WAAJ;APCR,AOAQ,QAAI,MAAJ;APCR,AOCQ,IAAA,SAAS,GAAG,IAAI,CAAC,GAAL,EAAZ;APAR,AOCQ,QAAM,EAAE,GAAG,IAAI,MAAJ,CAAW,MAAX,EAAmB,GAAnB,CAAX;APAR,AOCQ,QAAM,cAAc,GAAG,iBAAiB,CAAC,OAAlB,CAA0B,EAA1B,EAA8B,OAA9B,CAAvB;APAR,AOCQ,IAAA,WAAW,GAAG,OAAA,CAAA,qBAAA,CAAsB,SAAtB,CAAd;APAR,AOCQ,IAAA,MAAM,GAAG,OAAA,CAAA,eAAA,CAAgB,IAAhB,EAAsB,WAAtB,CAAT;APAR,AOCQ,IAAA,OAAA,CAAA,YAAA,CAAa,kBAAA,CAAA,UAAA,CAAW,oBAAxB,EAA8C,MAA9C;APAR,AOEQ,IAAA,SAAS,GAAG,IAAI,CAAC,GAAL,EAAZ;APDR,AOEQ,QAAM,UAAU,GAAG,UAAU,CAAC,aAAX,CACf,mBADe,EAEf,UAAU,CAAC,aAAX,CAAyB,MAAzB,CAFe,EAGf,UAAU,CAAC,aAAX,CAAyB,OAAzB,CAHe,CAAnB,CAf0E,CAoB1E;APNR;AACA,AOMQ,IAAA,WAAW,GAAG,OAAA,CAAA,qBAAA,CAAsB,SAAtB,CAAd;APLR,AOMQ,IAAA,MAAM,GAAG,OAAA,CAAA,eAAA,CAAgB,IAAhB,EAAsB,WAAtB,CAAT;APLR,AOMQ,IAAA,OAAA,CAAA,YAAA,CAAa,kBAAA,CAAA,UAAA,CAAW,sBAAxB,EAAgD,MAAhD,EAvB0E,CAwB1E;APNR,AOOK,GAzBD;APmBJ,AOQC,CAnCD;AP4BA;AACA,AOQA,SAAS,cAAT,GAAuB;APPvB,AOQI,MAAM,GAAG,GAAG,sBAAZ;APPJ,AOSI,EAAA,KAAK,CAAC,GAAD,CAAL,CACK,IADL,CACU,UAAA,QAAA,EAAQ;APTtB,AOS0B,WAAA,QAAQ,CAAC,WAAT,EAAA;APR1B,AOQgD,GAD5C,EAEK,IAFL,CAEU,UAAA,KAAA,EAAK;APRnB,AOQuB,WAAA,QAAA,CAAA,iBAAA,CAAkB,IAAI,UAAJ,CAAe,KAAf,CAAlB,EAAyC,OAAzC,CAAA;APPvB,AOOwE,GAFpE,EAGK,IAHL,CAGU,UAAA,KAAA,EAAK;APPnB,AOOwB,WAAA,UAAU,GAAY,KAAtB;APNxB,AOMiE,GAH7D,EAIK,IAJL,CAIW,UAAA,CAAA,EAAC;APNhB,AOOY,IAAA,eAAe;APN3B,AOOS,GANL;APAJ,AOOC;APND;AACA,AOOA,SAAS,eAAT,GAAwB;APNxB,AOOI,MAAM,GAAG,GAAG,iDAAZ;APNJ,AOQI,EAAA,KAAK,CAAC,GAAD,CAAL,CACC,IADD,CACM,UAAA,QAAA,EAAQ;APRlB,AOQsB,WAAA,QAAQ,CAAC,IAAT,EAAA;APPtB,AOOqC,GADjC,EAEC,IAFD,CAEM,UAAA,IAAA,EAAI;APPd,AOQQ,IAAA,iBAAiB,GAAG,IAApB;APPR,AOQQ,IAAA,mBAAmB,GAAG,UAAU,CAAC,aAAX,CAAyB,IAAzB,CAAtB;APPR,AOQQ,IAAA,OAAO,CAAC,GAAR,CAAY,sBAAZ,EAAoC,mBAApC;APPR,AOQK,GAND;APDJ,AOQC;APPD;AACA,AOQA,SAAS,wBAAT,CAAkC,aAAlC,EAA2D,QAA3D,EAA+E;APP/E,AOQI,MAAM,UAAU,GAAG,OAAA,CAAA,kBAAA,CAAmB,kBAAA,CAAA,UAAA,CAAW,WAA9B,CAAnB;APPJ,AOQI,MAAI,SAAJ;APPJ,AOQI,MAAI,WAAJ;APPJ,AOSI,EAAA,SAAS,GAAG,IAAI,CAAC,GAAL,EAAZ;APRJ,AOUI,MAAM,GAAG,GAAG,aAAa,CAAC,UAAD,CAAzB;APTJ,AOWI,EAAA,WAAW,GAAG,OAAA,CAAA,qBAAA,CAAsB,SAAtB,CAAd;APVJ,AOYI,MAAM,MAAM,GAAG,OAAA,CAAA,eAAA,CAAgB,GAAhB,EAAqB,WAArB,CAAf;APXJ,AOaI,EAAA,OAAA,CAAA,YAAA,CAAa,QAAb,EAAuB,MAAvB;APZJ,AOaC;APZD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ts.841fc46b.js","sourceRoot":"../src","sourcesContent":["export enum ElementIds {\n    NumberInput = 'number-input',\n    SearchStringInput = 'search-string-input',\n    ReplaceStringInput = 'replace-string-input',\n    FibSubmitButton = 'fib-submit-button',\n    WarSubmitButton = 'war-submit-button',\n    JSFibResultParagraph = 'fib-js-result',\n    JSWarResultParagraph = 'war-js-result',\n    WasmFibResultParagraph = 'fib-wasm-result',\n    WasmWarResultParagraph = 'war-wasm-result',\n}\n","\"use strict\";\n\n// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\nconst ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst SET = 1 << 2;\nconst MAP = 1 << 3;\nconst VAL_ALIGN_OFFSET = 5;\nconst VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 10;\nconst VAL_FLOAT = 1 << 11;\nconst VAL_NULLABLE = 1 << 12;\nconst VAL_MANAGED = 1 << 13;\nconst KEY_ALIGN_OFFSET = 14;\nconst KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\nconst KEY_SIGNED = 1 << 19;\nconst KEY_FLOAT = 1 << 20;\nconst KEY_NULLABLE = 1 << 21;\nconst KEY_MANAGED = 1 << 22;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\nconst CHUNKSIZE = 1024;\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const U32 = new Uint32Array(buffer);\n  const U16 = new Uint16Array(buffer);\n  var length = U32[(ptr + SIZE_OFFSET) >>> 2] >>> 1;\n  var offset = ptr >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  const parts = [];\n  do {\n    const last = U16[offset + CHUNKSIZE - 1];\n    const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    const memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  const rawExports = instance.exports;\n  const memory = rawExports.memory;\n  const table = rawExports.table;\n  const alloc = rawExports[\"__alloc\"];\n  const retain = rawExports[\"__retain\"];\n  const rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  function getKeyAlign(info) {\n    return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n  function __allocString(str) {\n    const length = str.length;\n    const ptr = alloc(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  baseModule.__allocString = __allocString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ptr);\n    return getStringImpl(buffer, ptr);\n  }\n\n  baseModule.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(\"unsupported align: \" + alignLog2);\n  }\n\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n  function __allocArray(id, values) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = alloc(length << align, ARRAYBUFFER_ID);\n    const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    const U32 = new Uint32Array(memory.buffer);\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) view[(buf >>> align) + i] = retain(values[i]);\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return arr;\n  }\n\n  baseModule.__allocArray = __allocArray;\n\n  /** Gets a view on the values of an array in the module's memory. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    const align = getValueAlign(info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT)\n          .subarray(buf >>>= align, buf + length);\n  }\n\n  baseModule.__getArrayView = __getArrayView;\n\n  /** Reads (copies) the values of an array from the module's memory. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  baseModule.__getArray = __getArray;\n\n  /** Reads (copies) the data of an ArrayBuffer from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  baseModule.__getArrayBuffer = __getArrayBuffer;\n\n  function getTypedArrayImpl(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  /** Gets a view on the values of a known-to-be Int8Array in the module's memory. */\n  baseModule.__getInt8Array = getTypedArrayImpl.bind(null, Int8Array, 0);\n  /** Gets a view on the values of a known-to-be Uint8Array in the module's memory. */\n  baseModule.__getUint8Array = getTypedArrayImpl.bind(null, Uint8Array, 0);\n  /** Gets a view on the values of a known-to-be Uint8ClampedArray in the module's memory. */\n  baseModule.__getUint8ClampedArray = getTypedArrayImpl.bind(null, Uint8ClampedArray, 0);\n  /** Gets a view on the values of a known-to-be Int16Array in the module's memory. */\n  baseModule.__getInt16Array = getTypedArrayImpl.bind(null, Int16Array, 1);\n  /** Gets a view on the values of a known-to-be Uint16Array in the module's memory. */\n  baseModule.__getUint16Array = getTypedArrayImpl.bind(null, Uint16Array, 1);\n  /** Gets a view on the values of a known-to-be Int32Array in the module's memory. */\n  baseModule.__getInt32Array = getTypedArrayImpl.bind(null, Int32Array, 2);\n  /** Gets a view on the values of a known-to-be Uint32Array in the module's memory. */\n  baseModule.__getUint32Array = getTypedArrayImpl.bind(null, Uint32Array, 2);\n  if (BIGINT) {\n    /** Gets a view on the values of a known-to-be-Int64Array in the module's memory. */\n    baseModule.__getInt64Array = getTypedArrayImpl.bind(null, BigInt64Array, 3);\n    /** Gets a view on the values of a known-to-be-Uint64Array in the module's memory. */\n    baseModule.__getUint64Array = getTypedArrayImpl.bind(null, BigUint64Array, 3);\n  }\n  /** Gets a view on the values of a known-to-be Float32Array in the module's memory. */\n  baseModule.__getFloat32Array = getTypedArrayImpl.bind(null, Float32Array, 2);\n  /** Gets a view on the values of a known-to-be Float64Array in the module's memory. */\n  baseModule.__getFloat64Array = getTypedArrayImpl.bind(null, Float64Array, 3);\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    var id = U32[(ptr + ID_OFFSET) >>> 2];\n    if (id <= U32[rttiBase >>> 2]) {\n      do if (id == baseId) return true;\n      while (id = getBase(id));\n    }\n    return false;\n  }\n\n  baseModule.__instanceof = __instanceof;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table  = baseModule.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, baseModule);\n}\n\n/** Wraps a WebAssembly function while also taking care of variable arguments. */\nfunction wrapFunction(fn, setargc) {\n  var wrap = (...args) => {\n    setargc(args.length);\n    return fn(...args);\n  }\n  wrap.original = fn;\n  return wrap;\n}\n\n/** Instantiates an AssemblyScript module using the specified imports. */\nfunction instantiate(module, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(module, imports)\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Instantiates an AssemblyScript module from a buffer using the specified imports. */\nfunction instantiateBuffer(buffer, imports) {\n  return instantiate(new WebAssembly.Module(buffer), imports);\n}\n\nexports.instantiateBuffer = instantiateBuffer;\n\n/** Instantiates an AssemblyScript module from a response using the specified imports. */\nasync function instantiateStreaming(response, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(response, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setargc = exports[\"__setargc\"] || function() {};\n  function hasOwnProperty(elem, prop) {\n    return Object.prototype.hasOwnProperty.call(elem, prop);\n  }\n  for (let internalName in exports) {\n    if (!hasOwnProperty(exports, internalName)) continue;\n    let elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!hasOwnProperty(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!hasOwnProperty(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this[THIS]); },\n            set: function(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          curr[name] = wrapFunction(elem, setargc);\n        } else { // for methods\n          Object.defineProperty(curr, name, {\n            value: function (...args) {\n              setargc(args.length);\n              return elem(this[THIS], ...args);\n            }\n          });\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!hasOwnProperty(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\") {\n        curr[name] = wrapFunction(elem, setargc);\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n\n  return module;\n}\n\nexports.demangle = demangle;\n","export function javascriptFibonacci(n: number): number {\n  if (n === 1) return 1;\n  if (n === 2) return 1;\n  return javascriptFibonacci(n - 1) + javascriptFibonacci(n - 2);\n}\n","export function getElapsedMiliSeconds(start: number): string {\n    const now = Date.now();\n    let elapsed = now - start;\n    return `${elapsed} miliseconds`;\n}\n","export function getNumberFromInput(inputId: string): number {\n    return Number((<HTMLInputElement>document.getElementById(inputId)).value);\n}\n","export function getResultString(result:number | string, elapsedTime: string): string{\n    let resultString = `elapsed time: ${elapsedTime}`;\n    if(result){\n        resultString = `result: ${result}\\n` + resultString;\n    }\n    return resultString;\n}\n","export function outputResult(outputId: string, result: string): void {\n    document.getElementById(outputId).textContent = result;\n}\n","export * from './fibonacci.function';\nexport * from './get-elapsed-seconds.function';\nexport * from './get-input-value.function';\nexport * from './get-result-string.function';\nexport * from './output-result.function';\n","import { ElementIds } from './enums/element-ids.enum';\nimport { WasmModule } from './models/wasm-module.model';\nimport { instantiateBuffer } from \"assemblyscript/lib/loader\";\nimport { getElapsedMiliSeconds, javascriptFibonacci, getNumberFromInput, getResultString, outputResult } from './functions/index';\n\nlet wasmModule: WasmModule;\n\nlet jsWarAndPeaceText: string;\nlet wasmWarAndPeaceText: number;\n\nconst imports = {\n    env: {\n        abort(_msg, _file, line, column) {\n            console.error(\"abort called at index.ts:\" + line + \":\" + column);\n        },\n        logToConsole(n: number): void {\n            console.log(`wasm output: ${n}`);\n        }\n    }\n};\n\nloadWasmModule();\n\ndocument.addEventListener('DOMContentLoaded', () => {\n\n    document.getElementById(ElementIds.FibSubmitButton).addEventListener('click', () => {\n        calculateFibonacciNumber(javascriptFibonacci, ElementIds.JSFibResultParagraph);\n\n        calculateFibonacciNumber(wasmModule.wasmFibonacci, ElementIds.WasmFibResultParagraph);\n    });\n\n    document.getElementById(ElementIds.WarSubmitButton).addEventListener('click', () => {\n        const search = (<HTMLInputElement>document.getElementById(ElementIds.SearchStringInput)).value;\n        const replace = (<HTMLInputElement>document.getElementById(ElementIds.ReplaceStringInput)).value;\n        let startTime: number;\n        let elapsedTime: string;\n        let result: string\n\n        startTime = Date.now();\n        const re = new RegExp(search, 'g')\n        const jsResultString = jsWarAndPeaceText.replace(re, replace);\n        elapsedTime = getElapsedMiliSeconds(startTime);\n        result = getResultString(null, elapsedTime);\n        outputResult(ElementIds.JSWarResultParagraph, result);\n        \n        startTime = Date.now();\n        const wasmResult = wasmModule.replaceString(\n            wasmWarAndPeaceText,\n            wasmModule.__allocString(search),\n            wasmModule.__allocString(replace)\n             );\n        //const wasmResultAsString = wasmModule.__getString(wasmResult);\n        elapsedTime = getElapsedMiliSeconds(startTime);\n        result = getResultString(null, elapsedTime);\n        outputResult(ElementIds.WasmWarResultParagraph, result);\n        //console.log(wasmResultAsString)\n    })\n\n});\n\nfunction loadWasmModule(): void {\n    const url = '/wasm/optimized.wasm';\n\n    fetch(url)\n        .then(response => response.arrayBuffer())\n        .then(bytes => instantiateBuffer(new Uint8Array(bytes), imports))\n        .then(bytes =>  wasmModule = <unknown>bytes as WasmModule)\n        .then( _ => {\n            loadWarAndPeace(); \n        });\n}\n\nfunction loadWarAndPeace():void{\n    const url = 'https://www.gutenberg.org/files/2600/2600-0.txt';\n    \n    fetch(url)\n    .then(response => response.text())\n    .then(text => {\n        jsWarAndPeaceText = text;\n        wasmWarAndPeaceText = wasmModule.__allocString(text);\n        console.log('war and peace loaded', wasmWarAndPeaceText);\n    });\n}\n\nfunction calculateFibonacciNumber(fibonacciFunc: Function, outputId: ElementIds): void {\n    const inputValue = getNumberFromInput(ElementIds.NumberInput);\n    let startTime: number;\n    let elapsedTime: string\n\n    startTime = Date.now();\n\n    const fib = fibonacciFunc(inputValue);\n\n    elapsedTime = getElapsedMiliSeconds(startTime);\n\n    const result = getResultString(fib, elapsedTime);\n\n    outputResult(outputId, result);\n}\n"]}